import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import time
import os
from math import sin
from scipy import integrate

# Specifications for the plot
plt.rc('font', family='serif', size=16)
plt.rc('lines', linewidth=1.5)
plt.rc('legend', fontsize=12)

init_func = 0        #Select a single soliton


#Boundary Conditions
δ1 = 0
δ2 = 0


#Parametres of analytic solution
ν = 0.8
velocity = f'Velocity: {ν}'
print(velocity)
c = 1.0
λ = -8.3
κ = 1.0
γ = np.sqrt(1-ν**2/c**2)
χ = abs(λ/1.62)
ε = (3 * γ * χ) / (math.sqrt(2) * λ)
q = -1.0    # Equal to ±1 and -1 for the Good Boussinesq Eqn

###### Analytic solution. u_x is the Boussinesq field ###########
if (init_func==0):
    def f(x):
        """Single Soliton"""
        E = np.zeros_like(x)
        E_x = np.zeros_like(x)
        E_t = np.zeros_like(x)
        u = np.zeros_like(x)
        u_x = np.zeros_like(x)
        u_t = np.zeros_like(x)
        E = np.exp(γ * x / κ)
        E_x = (γ / κ) * np.exp(γ * x / κ)
        E_t = -(γ / κ) * ν * np.exp(γ * x / κ)
        u = (3 * κ * γ / (λ * ε)) * np.log(1 - ε *(1-E)/(1+E))
        u_x = -6 * (γ**2)/λ * E/((E+1)**2 + ε *(1-E**2))    # Modified Boussinesq Field
        return u_x

elif(init_func==1):
    def f(x):
        return u_x

#Grid: discreate space and time

xmin, xmax = -100.0, 100.0 # start and end of spatial domain
Nx = 2000 # number of spatial points
x = np.linspace(xmin, xmax, Nx) # discretization of space. Vector with Nx point. The first one is xmin and the last one is nmax
dx = float((xmax-xmin)/(Nx-1)) # spatial step size
Delta_x = f'Delta x: {dx}'
print(Delta_x)
dt = 0.002 # stable time step (?)
Delta_t = f'Delta t: {dt}'
print(Delta_t)
Nt = 60000 # number of time steps
r = dt/dx
p = dt/(dx**2)
print(f' r=dt/dx = {r}')
print(f' p=dt/dx^2 = {p}')
time_array = np.zeros(Nt+1) # Discretisation of time.

# Definition of required vectors
w_corrector=np.zeros([Nt+1,len(x)]) # Matrix with Nt+1 row, each one represent the soliton at a certain time. \
# The number of column is the number fo points in the vector x.
w_predictor=np.zeros([Nt+1,len(x)]) # Temporary solution. Note that the first two rows are not used and cantain zeros. This is the w_tilde.
wanalytical = np.zeros([Nt+1, len(x)]) # Holds the analytical solution of the Boussinesq equation
error = np.zeros(Nt+1)
x_error = np.zeros(Nt+1)
rms_plot = np.zeros(Nt+1)
Energy_analytic = np.zeros(Nt+1)
Energy_numeric = np.zeros(Nt+1)

######## Initial conditions ############
wanalytical[0,:] = f(x+60) # Analytic solution at t=0. Time zero. Solution shifted by 60 on the left.
m = x+60-dt*ν  # Argument of the analytic solution at t=dt. Time 1.
wanalytical[1,:] = f(m) # Analytic solution at t=dt. Time one.
w_corrector[0,:] = f(x+60) # Analytic solution at t=0
w_corrector[1,:] = f(m) # Analytic solution at t=dt

istep = 1 # Time start at t=2 since at t=0 and t=1 we are usign the analytic solutions
time_array[istep] = dt

########### Function used in the ODE
g_output = np.zeros(len(x))
def g(vector):
    g_output = vector + λ * vector**2 + χ **2 * vector**3
    return g_output

# Implementation of the algorithms
while istep < Nt:
    istep = istep + 1
    time_array[istep] = time_array[istep-1] + dt
    # Compute exact solution
    m = x+60-time_array[istep]*ν
    wanalytical[istep,:]= f(m)

    ######### CALCULATE NUMERICAL SOLUTIONI ##########

    Cn = w_corrector[istep-1,:]  # Corrector w_j^(n)
    Cnn = w_corrector[istep-2,:]  # Corrector w_j^(n-1)

    # ny.roll schift the array. roll with 1 create an array that start with the last elemnt of the original array
    #(effectively schifting backard)
    Cn_m = np.roll(Cn,1)  # It corresponds to w_(j-1)^(n)
    Cn_m[0] = δ1
    Cn_mm = np.roll(Cn,2)
    Cn_mm[1] = δ1
    Cn_mm[0] = Cn[0]
    Cnn_m = np.roll(Cnn,1) # It corresponds to w_(j-1)^(n-1)
    Cnn_m[0] = δ1
    Cnn_mm = np.roll(Cnn,2)
    Cnn_mm[1] = δ1
    Cnn_mm[0] = Cnn[0]

    # ny.roll schift the array. roll with 1 create an array that start with the secon elemnt of the original array
    #(effectively schiting forward)
    Cn_p = np.roll(Cn,-1) # It corresponds to w_(j+1)^(n)
    Cn_p[Nx-1] = δ2
    Cn_pp = np.roll(Cn,-2)
    Cn_pp[Nx-2] = δ2
    Cn_pp[Nx-1] = Cn[Nx-1]
    Cnn_p = np.roll(Cnn,-1) # It corresponds to w_(j+1)^(n-1)
    Cnn_p[0] = δ2
    Cnn_pp = np.roll(Cnn,-2)
    Cnn_pp[1] = δ2
    Cnn_pp[0] = Cnn[0]

    ######## Implementing the Predictor ###############
    w_predictor[istep,:] = 2*Cn - Cnn + (c * r)**2 *(g(Cn_p)-2*g(Cn)+g(Cn_m)) - (c * κ * p)**2 * (Cn_pp - 4 * Cn_p + 6 * Cn - 4 * Cn_m + Cn_mm)

    Pn = w_predictor[istep,:] # Predictor w_tilde_j^(n+1)
    Pn_m = np.roll(Pn,1)  # It corresponds to w_tilde_(j-1)^(n+1)
    Pn_m[0] = δ1
    Pn_mm = np.roll(Pn,2)
    Pn_mm[1] = δ1
    Pn_mm[0] = Pn[0]
    Pn_p = np.roll(Pn,-1) # It corresponds to w_tilde_(j+1)^(n+1)
    Pn_p[Nx-1] = δ2
    Pn_pp = np.roll(Pn,-2)
    Pn_pp[Nx-2] = δ2
    Pn_pp[Nx-1] = Pn[Nx-1]

    # Implementing the Corrector
    w_corrector[istep,:] = 2*Cn - Cnn + (c * r )**2 / 12 *(g(Pn_p)-2*g(Pn)+g(Pn_m) + 10 * (g(Cn_p)-2*g(Cn)+g(Cn_m)) + g(Cnn_p)-2*g(Cnn)+g(Cnn_m)) \
                           - (c * κ * p)**2 / 12 * (Pn_pp - 4 * Pn_p + 6 * Pn - 4 * Pn_m + Pn_mm + 10 * (Cn_pp - 4 * Cn_p + 6 * Cn - 4 * Cn_m + Cn_mm) \
                                                    + Cnn_pp - 4 * Cnn_p + 6 * Cnn - 4 * Cnn_m + Cnn_mm)

    # Energy
    Energy_analytic[istep] = integrate.simpson(wanalytical[istep,:])       # assumes that x is equally spaced for the purpose of processing simpson() with a single positional argument
    Energy_numeric[istep] = integrate.simpson(w_corrector[istep,:])


    # Error (rms)
    error_istep =  abs(w_corrector[istep,:] - wanalytical[istep,:])
    error[istep] = np.max(error_istep)
    x_error[istep] = np.argmax(error_istep)

    # ROOT MEAN SQUARE
    rms = np.sqrt(np.sum((w_corrector[istep,:]-w_corrector[0,:])**2) / len(x) )
    rms_plot[istep] = rms

# Create figure for animation
fig, ax = plt.subplots(figsize=(10, 6))
ax.set_xlabel('x', fontsize=18)
ax.set_ylabel('Boussinesq Field (w(x,t))', fontsize=16)
ax.set_title('Numerical vs Exact Solution')

# Initialize plots
line1, = ax.plot([], [], label="Numeric", color='b')
line2, = ax.plot([], [], label="Exact", color='r')
ax.legend(loc="upper right")

# Set axis limits
ax.set_xlim(x.min(), x.max())
ax.set_ylim(w_corrector.min() - 0.1, w_corrector.max() + 0.1)

# Define the animation update function
def update(print_time):
    line1.set_data(x, w_corrector[print_time, :])
    line2.set_data(x, wanalytical[print_time, :])
    ax.set_title(f'Total time = {round(print_time * dt, 1)}')
    return line1, line2

# Create animation (Frames every 1000 timesteps)
ani = animation.FuncAnimation(fig, update, frames=range(0, Nt + 1, 1000), interval=100)

fig.tight_layout()

# Show the animation
plt.show()

# Error Plot - IMPROVED
plt.figure(figsize=(10, 6))
plt.plot(time_array, error, label='Maximum Absolute Error', color='b', linewidth=2)

# Better formatting for axes
plt.xlabel('Time', fontsize=14)
plt.ylabel('Maximum Absolute Error', fontsize=14)

# Clean up ticks - fewer, more meaningful ticks
plt.gca().xaxis.set_major_locator(plt.MaxNLocator(6))  # Fewer x ticks
plt.gca().yaxis.set_major_locator(plt.MaxNLocator(6))  # Fewer y ticks

# Add grid for better readability
plt.grid(True, alpha=0.3, linestyle='--')

plt.title('Error Evolution Over Time', fontsize=16)
plt.legend(fontsize=12)
plt.tight_layout()  # Ensures everything fits nicely
plt.show()

# Energy Plot - IMPROVED
plt.figure(figsize=(10, 6))
plt.plot(time_array, Energy_analytic, label="Analytical Solution", color='r', linewidth=2)
# Plot numerical solution as bullet points overlaid over the analytic solution
plt.plot(time_array, Energy_numeric, 'o', label="Numerical Solution", color='b', markersize=3)

# Better formatting for axes
plt.xlabel('Time', fontsize=14)
plt.ylabel('Energy', fontsize=14)

# Clean up ticks
plt.gca().xaxis.set_major_locator(plt.MaxNLocator(6))
plt.gca().yaxis.set_major_locator(plt.MaxNLocator(6))

# Add grid for better readability
plt.grid(True, alpha=0.3, linestyle='--')

plt.title('Energy Conservation Comparison', fontsize=16)
plt.legend(fontsize=12)
plt.tight_layout()
plt.show()

# Set file directory
save_dir = r"C:\Users\adria\OneDrive\Pictures"

# Ensure the directory exists
if not os.path.exists(save_dir):
    os.makedirs(save_dir)

# NEW CODE: Plot soliton at different times in a single figure
# Calculate time steps at 30 second intervals
time_step_30s = int(30 / dt)  # Number of time steps for 30 seconds
num_snapshots = 5  # Number of snapshots to display

plt.figure(figsize=(12, 8))
plt.title('Soliton Evolution Over Time (30s intervals)', fontsize=16)
plt.xlabel('x', fontsize=14)
plt.ylabel('Boussinesq Field (w(x,t))', fontsize=14)

colors = plt.cm.viridis(np.linspace(0, 1, num_snapshots))  # Color gradient for different times

for i in range(num_snapshots):
    time_idx = i * time_step_30s
    if time_idx < Nt:  # Make sure we don't exceed the array bounds
        time_val = time_array[time_idx]
        label = f't = {int(time_val)}s'

        # Plot analytical solution as solid line
        plt.plot(x, wanalytical[time_idx, :], color=colors[i], linewidth=2, label=label)

        # Plot numerical solution as dots (with lower density for clarity)
        # Plotting fewer points for clarity (every 50th point)
        plt.plot(x[::50], w_corrector[time_idx, ::50], 'o', color=colors[i],
                 markersize=4, alpha=0.8)

plt.grid(True, alpha=0.3, linestyle='--')
plt.legend(fontsize=12)
plt.tight_layout()

# Save the figure
soliton_plot_path = os.path.join(save_dir, "soliton_evolution_30s.png")
plt.savefig(soliton_plot_path, dpi=300)
print(f"Saved: {soliton_plot_path}")
plt.show()

# Final energy plot with bullet points - IMPROVED
plt.figure(figsize=(10, 6))
plt.plot(time_array, Energy_analytic, label="Analytical Solution", color='r', linewidth=2)
# Plot numerical solution as bullet points
plt.plot(time_array[::500], Energy_numeric[::500], 'o', label="Numerical Solution", color='b', markersize=4)

# Better formatting
plt.xlabel('Time', fontsize=14)
plt.ylabel('Energy', fontsize=14)

# Clean up ticks
plt.gca().xaxis.set_major_locator(plt.MaxNLocator(6))
plt.gca().yaxis.set_major_locator(plt.MaxNLocator(6))

plt.grid(True, alpha=0.3, linestyle='--')
plt.title('Energy Conservation Comparison', fontsize=16)
plt.legend(fontsize=12)
plt.tight_layout()
energy_plot_path = os.path.join(save_dir, "M_energy_plot_blue.png")
plt.savefig(energy_plot_path, dpi=300)
print(f"Saved: {energy_plot_path}")
plt.close()
