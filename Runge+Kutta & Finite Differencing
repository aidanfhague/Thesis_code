import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.fft import fft, ifft, fftfreq
import matplotlib.gridspec as gridspec

# Parameters
L = 120.0  # Domain length [-L/2, L/2]
N = 512    # Number of spatial points
dx = L / N  # Spatial step
dt = 0.001  # Time step
T = 120      # Total simulation time
num_frames = 300  # Number of frames to save for animation

# Parameter for the solitary wave
b = 0.2
c = np.sqrt(1 - 4 * b**2)  # Wave speed for right-moving wave
x0 = 0  # Initial position

# Spatial grid
x = np.linspace(-L/2, L/2, N, endpoint=False)
k = 2 * np.pi * fftfreq(N, d=dx)  # Wave numbers

# Analytical solution function
def exact_solution(x, t, b, c, x0):
    """Exact soliton solution of the Boussinesq equation"""
    return 2 * b**2 * np.cosh(b * (x - x0 - c * t))**(-2)

# Initial conditions based on the exact solution
u0 = exact_solution(x, 0, b, c, x0)
ut0 = 4 * b**3 * c * np.cosh(b * (x - x0))**(-2) * np.tanh(b * (x - x0))  # Time derivative at t=0

# Function to compute spatial derivatives using FFT
def compute_derivatives(u):
    """Compute spatial derivatives using Fourier transform"""
    u_hat = fft(u)
    ux_hat = 1j * k * u_hat
    uxx_hat = -k**2 * u_hat
    uxxxx_hat = k**4 * u_hat

    ux = ifft(ux_hat).real
    uxx = ifft(uxx_hat).real
    uxxxx = ifft(uxxxx_hat).real

    return ux, uxx, uxxxx

# RK4 time evolution (System approach)
def simulate_rk4():
    # Initialize
    u = u0.copy()
    v = ut0.copy()  # v = du/dt

    # Storage for animation
    times = np.linspace(0, T, num_frames)
    u_numerical = np.zeros((num_frames, N))
    u_exact = np.zeros((num_frames, N))

    # Simulation loop
    frame_idx = 0
    for t in np.arange(0, T + dt/2, dt):
        if abs(t - times[frame_idx]) < dt/2:
            u_numerical[frame_idx] = u
            u_exact[frame_idx] = exact_solution(x, t, b, c, x0)
            frame_idx += 1
            if frame_idx >= num_frames:
                break

        # RK4 step for the system
        k1_u = v
        _, uxx, uxxxx = compute_derivatives(u)
        k1_v = uxx - 6*u*uxx - 6*(compute_derivatives(u)[0])**2 - uxxxx

        k2_u = v + 0.5*dt*k1_v
        _, uxx, uxxxx = compute_derivatives(u + 0.5*dt*k1_u)
        k2_v = uxx - 6*(u + 0.5*dt*k1_u)*uxx - 6*(compute_derivatives(u + 0.5*dt*k1_u)[0])**2 - uxxxx

        k3_u = v + 0.5*dt*k2_v
        _, uxx, uxxxx = compute_derivatives(u + 0.5*dt*k2_u)
        k3_v = uxx - 6*(u + 0.5*dt*k2_u)*uxx - 6*(compute_derivatives(u + 0.5*dt*k2_u)[0])**2 - uxxxx

        k4_u = v + dt*k3_v
        _, uxx, uxxxx = compute_derivatives(u + dt*k3_u)
        k4_v = uxx - 6*(u + dt*k3_u)*uxx - 6*(compute_derivatives(u + dt*k3_u)[0])**2 - uxxxx

        u = u + dt*(k1_u + 2*k2_u + 2*k3_u + k4_u)/6
        v = v + dt*(k1_v + 2*k2_v + 2*k3_v + k4_v)/6

    return u_numerical, u_exact, times

# Finite difference time evolution (Direct approach)
def simulate_fd():
    # Need two initial time levels for the finite difference method
    u_prev = u0.copy()

    # Compute u at dt
    _, uxx, uxxxx = compute_derivatives(u_prev)
    acceleration = uxx - 6*u_prev*uxx - 6*(compute_derivatives(u_prev)[0])**2 - uxxxx
    u_current = u_prev + dt*ut0 + 0.5*(dt**2)*acceleration

    # Storage for animation
    times = np.linspace(0, T, num_frames)
    u_numerical = np.zeros((num_frames, N))
    u_exact = np.zeros((num_frames, N))

    # Store initial state
    u_numerical[0] = u_prev
    u_exact[0] = exact_solution(x, 0, b, c, x0)

    # Simulation loop
    frame_idx = 1
    for t in np.arange(dt, T + dt/2, dt):
        if abs(t - times[frame_idx]) < dt/2:
            u_numerical[frame_idx] = u_current
            u_exact[frame_idx] = exact_solution(x, t, b, c, x0)
            frame_idx += 1
            if frame_idx >= num_frames:
                break

        # FD time evolution using central difference
        _, uxx, uxxxx = compute_derivatives(u_current)
        acceleration = uxx - 6*u_current*uxx - 6*(compute_derivatives(u_current)[0])**2 - uxxxx
        u_next = 2*u_current - u_prev + dt**2 * acceleration

        # Update for next step
        u_prev = u_current
        u_current = u_next

    return u_numerical, u_exact, times

# Run one of the simulations (choose RK4 or FD)
method = "RK4"  # or "FD"

if method == "FD":
    u_numerical, u_exact, times = simulate_rk4()
    title = "Boussinesq Equation: Fourier Spectral with RK4 Method"
else:
    u_numerical, u_exact, times = simulate_fd()
    title = "Boussinesq Equation: Fourier Spectral with Finite Difference Method"

# Error calculation
error = u_exact - u_numerical
L2_error = np.sqrt(np.mean(error**2, axis=1))
Linf_error = np.max(np.abs(error), axis=1)

# Create animation
fig = plt.figure(figsize=(12, 10))
gs = gridspec.GridSpec(3, 1, height_ratios=[3, 1, 1])

# Wave solution plot
ax1 = plt.subplot(gs[0])
line_exact, = ax1.plot([], [], 'r-', label='Exact Solution')
line_numerical, = ax1.plot([], [], 'b--', label='Numerical Solution')
ax1.set_xlim(-L/2, L/2)
ax1.set_ylim(0, 0.1)
ax1.set_xlabel('x')
ax1.set_ylabel('u(x,t)')
ax1.legend()

# Error plot
ax2 = plt.subplot(gs[1])
line_error, = ax2.plot([], [], 'g-')
ax2.set_xlim(-L/2, L/2)
ax2.set_ylim(-0.01, 0.01)
ax2.set_xlabel('x')
ax2.set_ylabel('Error')

# L2 and Linf error plot
ax3 = plt.subplot(gs[2])
line_L2, = ax3.plot([], [], 'b-', label='L2 Error')
line_Linf, = ax3.plot([], [], 'r-', label='Linf Error')
ax3.set_xlim(0, T)
ax3.set_ylim(0, max(max(L2_error), max(Linf_error)) * 1.1)
ax3.set_xlabel('Time')
ax3.set_ylabel('Error Norm')
ax3.legend()

fig.suptitle(title)

def init():
    line_exact.set_data([], [])
    line_numerical.set_data([], [])
    line_error.set_data([], [])
    line_L2.set_data([], [])
    line_Linf.set_data([], [])
    return line_exact, line_numerical, line_error, line_L2, line_Linf

def animate(i):
    line_exact.set_data(x, u_exact[i])
    line_numerical.set_data(x, u_numerical[i])
    line_error.set_data(x, error[i])
    line_L2.set_data(times[:i+1], L2_error[:i+1])
    line_Linf.set_data(times[:i+1], Linf_error[:i+1])
    ax1.set_title(f'Time = {times[i]:.2f}')
    return line_exact, line_numerical, line_error, line_L2, line_Linf

ani = FuncAnimation(fig, animate, frames=num_frames, init_func=init, blit=True, interval=50)

# To save the animation
# ani.save('boussinesq_simulation.mp4', writer='ffmpeg', fps=20)

plt.tight_layout()
plt.show()
