import math
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.fft import fft, ifft, fftfreq
import matplotlib.gridspec as gridspec

# Parameters
L = 120.0  # Domain length [-L/2, L/2]
N = 512    # Number of spatial points
dx = L / N  # Spatial step
dt = 0.001  # Time step
T = 40      # Total simulation time
num_frames = 100  # Number of frames to save for animation

# Parameters for the modified Boussinesq field with cubic term
kappa = 1.0      # kappa parameter
lambda_param = -8.3  # lambda parameter
nu = 0.8         # nu parameter (wave speed)
c = 1.0          # wave speed parameter in the PDE
gamma = np.sqrt(1-nu**2/c**2)      # gamma parameter
chi = abs(lambda_param/1.62)       # chi parameter for cubic term
epsilon = (3 * gamma * chi) / (math.sqrt(2) * lambda_param)   # epsilon parameter


# Spatial grid
x = np.linspace(-L/2, L/2, N, endpoint=False)
k = 2 * np.pi * fftfreq(N, d=dx)  # Wave numbers

# Modified Boussinesq field functions with cubic term
def modified_boussinesq_field(x, t):
    """Modified Boussinesq Field with cubic term"""
    # Shifted x to account for time evolution
    x_shifted = x - nu * t

    E = np.exp(gamma * x_shifted / kappa)
    u_x = - 6 * (gamma**2)/lambda_param * E/((E+1)**2 + epsilon *(1-E**2))

    return u_x

def modified_boussinesq_field_t(x, t):
    """Time derivative of Modified Boussinesq Field with cubic term"""
    # To compute the time derivative, we use the fact that
    # ∂u/∂t = -ν * ∂u/∂x when u(x,t) = f(x - νt)

    # First calculate the spatial derivative at the shifted position
    E = np.exp(gamma * x / kappa)
    E_x = (gamma / kappa) * np.exp(gamma * x / kappa)

    # Denominator and its derivative
    denom = (E+1)**2 + epsilon *(1-E**2)
    denom_x = 2*(E+1)*E_x + epsilon*(-2*E*E_x)

    # Derivative of numerator
    num = E
    num_x = E_x

    # Using quotient rule for derivative of u_x with respect to x
    u_xx = - 6 * (gamma**2)/lambda_param * (num_x*denom - num*denom_x)/(denom**2)

    # Time derivative
    u_t = -nu * u_xx

    return u_t

# Initial conditions based on the modified Boussinesq field
u0 = modified_boussinesq_field(x, 0)
ut0 = modified_boussinesq_field_t(x, 0)

# Function to compute spatial derivatives using FFT
def compute_derivatives(u):
    """Compute spatial derivatives using Fourier transform"""
    u_hat = fft(u)
    ux_hat = 1j * k * u_hat
    uxx_hat = -k**2 * u_hat
    uxxxx_hat = k**4 * u_hat

    ux = ifft(ux_hat).real
    uxx = ifft(uxx_hat).real
    uxxxx = ifft(uxxxx_hat).real

    return ux, uxx, uxxxx

# RK4 time evolution (System approach) with cubic term
def simulate_rk4():
    # Initialize
    u = u0.copy()
    v = ut0.copy()  # v = du/dt

    # Storage for animation
    times = np.linspace(0, T, num_frames)
    u_numerical = np.zeros((num_frames, N))
    u_exact = np.zeros((num_frames, N))

    # Simulation loop
    frame_idx = 0
    for t in np.arange(0, T + dt/2, dt):
        if abs(t - times[frame_idx]) < dt/2:
            u_numerical[frame_idx] = u
            u_exact[frame_idx] = modified_boussinesq_field(x, t)
            frame_idx += 1
            if frame_idx >= num_frames:
                break

        # RK4 step for the system with cubic term
        k1_u = v
        _, uxx, uxxxx = compute_derivatives(u)
        # Compute the cubic term for RK4
        u_squared = u**2
        u_cubed = u**3
        u_squared_xx = compute_derivatives(u_squared)[1]
        u_cubed_xx = compute_derivatives(u_cubed)[1]

        # New equation: v_t = c^2 * [uxx + lambda * (u^2)_xx + chi^2 * (u^3)_xx - kappa^2 * uxxxx]
        k1_v = c**2 * (uxx + lambda_param * u_squared_xx + chi**2 * u_cubed_xx - kappa**2 * uxxxx)

        k2_u = v + 0.5*dt*k1_v
        u_temp = u + 0.5*dt*k1_u
        _, uxx, uxxxx = compute_derivatives(u_temp)
        # Compute the cubic term for RK4
        u_squared = u_temp**2
        u_cubed = u_temp**3
        u_squared_xx = compute_derivatives(u_squared)[1]
        u_cubed_xx = compute_derivatives(u_cubed)[1]

        k2_v = c**2 * (uxx + lambda_param * u_squared_xx + chi**2 * u_cubed_xx - kappa**2 * uxxxx)

        k3_u = v + 0.5*dt*k2_v
        u_temp = u + 0.5*dt*k2_u
        _, uxx, uxxxx = compute_derivatives(u_temp)
        # Compute the cubic term for RK4
        u_squared = u_temp**2
        u_cubed = u_temp**3
        u_squared_xx = compute_derivatives(u_squared)[1]
        u_cubed_xx = compute_derivatives(u_cubed)[1]

        k3_v = c**2 * (uxx + lambda_param * u_squared_xx + chi**2 * u_cubed_xx - kappa**2 * uxxxx)

        k4_u = v + dt*k3_v
        u_temp = u + dt*k3_u
        _, uxx, uxxxx = compute_derivatives(u_temp)
        # Compute the cubic term for RK4
        u_squared = u_temp**2
        u_cubed = u_temp**3
        u_squared_xx = compute_derivatives(u_squared)[1]
        u_cubed_xx = compute_derivatives(u_cubed)[1]

        k4_v = c**2 * (uxx + lambda_param * u_squared_xx + chi**2 * u_cubed_xx - kappa**2 * uxxxx)

        u = u + dt*(k1_u + 2*k2_u + 2*k3_u + k4_u)/6
        v = v + dt*(k1_v + 2*k2_v + 2*k3_v + k4_v)/6

    return u_numerical, u_exact, times

# Finite difference time evolution (Direct approach) with cubic term
def simulate_fd():
    # Need two initial time levels for the finite difference method
    u_prev = u0.copy()

    # Compute u at dt
    _, uxx, uxxxx = compute_derivatives(u_prev)
    # Compute the cubic term
    u_squared = u_prev**2
    u_cubed = u_prev**3
    u_squared_xx = compute_derivatives(u_squared)[1]
    u_cubed_xx = compute_derivatives(u_cubed)[1]

    # New acceleration: c^2 * [uxx + lambda * (u^2)_xx + chi^2 * (u^3)_xx - kappa^2 * uxxxx]
    acceleration = c**2 * (uxx + lambda_param * u_squared_xx + chi**2 * u_cubed_xx - kappa**2 * uxxxx)
    u_current = u_prev + dt*ut0 + 0.5*(dt**2)*acceleration

    # Storage for animation
    times = np.linspace(0, T, num_frames)
    u_numerical = np.zeros((num_frames, N))
    u_exact = np.zeros((num_frames, N))

    # Store initial state
    u_numerical[0] = u_prev
    u_exact[0] = modified_boussinesq_field(x, 0)

    # Simulation loop
    frame_idx = 1
    for t in np.arange(dt, T + dt/2, dt):
        if abs(t - times[frame_idx]) < dt/2:
            u_numerical[frame_idx] = u_current
            u_exact[frame_idx] = modified_boussinesq_field(x, t)
            frame_idx += 1
            if frame_idx >= num_frames:
                break

        # FD time evolution using central difference with cubic term
        _, uxx, uxxxx = compute_derivatives(u_current)
        # Compute the cubic term
        u_squared = u_current**2
        u_cubed = u_current**3
        u_squared_xx = compute_derivatives(u_squared)[1]
        u_cubed_xx = compute_derivatives(u_cubed)[1]

        # New acceleration
        acceleration = c**2 * (uxx + lambda_param * u_squared_xx + chi**2 * u_cubed_xx - kappa**2 * uxxxx)
        u_next = 2*u_current - u_prev + dt**2 * acceleration

        # Update for next step
        u_prev = u_current
        u_current = u_next

    return u_numerical, u_exact, times

# Run one of the simulations (choose RK4 or FD)
method = "RK4"  # or "FD"

if method == "RK4":
    u_numerical, u_exact, times = simulate_rk4()
    title = "Modified Boussinesq Equation with Cubic Term: Fourier Spectral with RK4 Method"


else:
    u_numerical, u_exact, times = simulate_fd()
    title = "Modified Boussinesq Equation with Cubic Term: Fourier Spectral with Finite Difference Method"


# Error calculation
error = u_exact - u_numerical
L2_error = np.sqrt(np.mean(error**2, axis=1))
Linf_error = np.max(np.abs(error), axis=1)

# Create animation
fig = plt.figure(figsize=(12, 10))
gs = gridspec.GridSpec(3, 1, height_ratios=[3, 1, 1])

# Wave solution plot
ax1 = plt.subplot(gs[0])
line_exact, = ax1.plot([], [], 'r-', label='Exact Solution')
line_numerical, = ax1.plot([], [], 'b--', label='Numerical Solution')
ax1.set_xlim(-L/2, L/2)
ax1.set_ylim(-1, 1)  # Adjust as needed for your modified field
ax1.set_xlabel('x')
ax1.set_ylabel('u_x(x,t)')
ax1.legend()

# Error plot
ax2 = plt.subplot(gs[1])
line_error, = ax2.plot([], [], 'g-')
ax2.set_xlim(-L/2, L/2)
ax2.set_ylim(-0.1, 0.1)  # Adjust as needed
ax2.set_xlabel('x')
ax2.set_ylabel('Error')

# L2 and Linf error plot
ax3 = plt.subplot(gs[2])
line_L2, = ax3.plot([], [], 'b-', label='L2 Error')
line_Linf, = ax3.plot([], [], 'r-', label='Linf Error')
ax3.set_xlim(0, T)
ax3.set_ylim(0, 0.1)  # Will be adjusted in the first animation frame
ax3.set_xlabel('Time')
ax3.set_ylabel('Error Norm')
ax3.legend()

fig.suptitle(title)

def init():
    line_exact.set_data([], [])
    line_numerical.set_data([], [])
    line_error.set_data([], [])
    line_L2.set_data([], [])
    line_Linf.set_data([], [])
    return line_exact, line_numerical, line_error, line_L2, line_Linf

def animate(i):
    line_exact.set_data(x, u_exact[i])
    line_numerical.set_data(x, u_numerical[i])
    line_error.set_data(x, error[i])
    line_L2.set_data(times[:i+1], L2_error[:i+1])
    line_Linf.set_data(times[:i+1], Linf_error[:i+1])

    # Adjust y-axis limits for the first two plots based on current data
    if i == 0:
        max_val = max(np.max(np.abs(u_exact)), np.max(np.abs(u_numerical))) * 1.1
        ax1.set_ylim(-max_val, max_val)

        max_err = np.max(np.abs(error)) * 1.1
        ax2.set_ylim(-max_err, max_err)

        max_norm_err = max(np.max(L2_error), np.max(Linf_error)) * 1.1
        ax3.set_ylim(0, max_norm_err)

    ax1.set_title(f'Time = {times[i]:.2f}')
    return line_exact, line_numerical, line_error, line_L2, line_Linf

ani = FuncAnimation(fig, animate, frames=num_frames, init_func=init, blit=True, interval=50)

# To save the animation
# ani.save('modified_boussinesq_cubic_simulation.mp4', writer='ffmpeg', fps=20)

plt.tight_layout()
plt.show()
